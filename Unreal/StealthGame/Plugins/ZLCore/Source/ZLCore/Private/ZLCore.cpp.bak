// Copyright 1998-2018 Epic Games, Inc. All Rights Reserved.

#include "ZLCore.h"
#include "ZeroLatencyAPI.h"
#include "ZLCallbackHandler.h"
#include "Engine/World.h"
#include "GameFramework/PlayerController.h"
#include "Engine/NetConnection.h"
#include "UnrealEngine.h"
#include "ZLIPCConnectionHandle.h"
#include "ELoggingLevel.h"
#include "ZLStructParser.h"
#include "ZLProtoParser.h"

#pragma warning(push)
#pragma warning(disable : 4647)
#pragma warning(disable : 4668)
#include "proto/controller/Input.pb.h"
#include "proto/player/Stats.pb.h"
#include "proto/GameSpaceCalibration.pb.h"
#include "proto/GameState.pb.h"
#include "proto/Session.pb.h"
#include "proto/Site.pb.h"
#include "proto/GameMasterView.pb.h"
#include "proto/Networking/Transmission.pb.h"
#include "proto/ProfileMaps.pb.h"
#include "proto/SiteBoundary.pb.h"
#include "proto/GameResults.pb.h"
#pragma warning(pop)

#include <Engine/GameEngine.h>
#include <Engine/LocalPlayer.h>
#include <Engine/Console.h>
#include <Kismet/GameplayStatics.h>

#define LOCTEXT_NAMESPACE "FZLCoreModule"

DEFINE_LOG_CATEGORY(LogZeroLatencyCore);

using namespace zl;

FZLCoreModule* CoreModule = nullptr;

void OnControllerInputChanged(const proto::controller::Input& packet)
{
	if (!CoreModule || !CoreModule->CallbackHandler || !CoreModule->CallbackHandler->OnBlasterInputUpdated.IsBound())
	{
		return;
	}

	CoreModule->CallbackHandler->OnBlasterInputUpdated.Broadcast(zl::ToStruct(packet));
}


void OnGameSpaceCalibrationChanged(const proto::GameSpaceCalibration& packet)
{
	if (!CoreModule || !CoreModule->CallbackHandler || !CoreModule->CallbackHandler->OnGamespaceCalibrationUpdated.IsBound())
	{
		return;
	}

	CoreModule->CallbackHandler->OnGamespaceCalibrationUpdated.Broadcast(packet.m11(), packet.m21(), packet.m31(), packet.m12(), packet.m22(), packet.m32());
}

void OnGameStateChanged(const proto::GameState& packet)
{
	if (!CoreModule || !CoreModule->CallbackHandler || !CoreModule->CallbackHandler->OnGameStateUpdated.IsBound())
	{
		return;
	}

	CoreModule->CallbackHandler->OnGameStateUpdated.Broadcast(zl::ToStruct(packet));
}

void OnPlayerProfileMapsChanged(const proto::ProfileMaps& packet)
{
	if (!CoreModule || !CoreModule->CallbackHandler || !CoreModule->CallbackHandler->OnPlayerProfileMapsUpdated.IsBound())
	{
		return;
	}

	CoreModule->CallbackHandler->OnPlayerProfileMapsUpdated.Broadcast(zl::ToStruct(packet));
}

void OnSessionChanged(const proto::Session& packet)
{
	if (!CoreModule || !CoreModule->CallbackHandler || !CoreModule->CallbackHandler->OnSessionUpdated.IsBound())
	{
		return;
	}

	CoreModule->CallbackHandler->OnSessionUpdated.Broadcast(zl::ToStruct(packet));
}

void OnSiteBoundaryChanged(const proto::SiteBoundary& packet)
{
	if (!CoreModule || !CoreModule->CallbackHandler || !CoreModule->CallbackHandler->OnSiteBoundaryUpdated.IsBound())
	{
		return;
	}

	CoreModule->CallbackHandler->OnSiteBoundaryUpdated.Broadcast(zl::ToStruct(packet));
}

void OnGameMasterViewChanged(const proto::GameMasterView& packet)
{
	if (!CoreModule || !CoreModule->CallbackHandler || !CoreModule->CallbackHandler->OnGameMasterViewUpdated.IsBound())
	{
		return;
	}

	CoreModule->CallbackHandler->OnGameMasterViewUpdated.Broadcast(zl::ToStruct(packet));
}

void FZLCoreModule::StartupModule()
{
	UE_LOG(LogZeroLatencyCore, Log, TEXT("Searching for ZeroLatencyIPC.dll directory."));

	CoreModule = this;

#if DEBUG_ZLAPI
	const auto ZLAPIDllSubdir = TEXT("Plugins/ZLCore/ZLAPI/Debug");
#else
	const auto ZLAPIDllSubdir = TEXT("Plugins/ZLCore/ZLAPI/Release");
#endif

	//TODO: Improve dll searching. Should check all subdirectories of plugins for zlcore.
	//Game/source first
	auto CppAPIDirectory = FPaths::ProjectDir() / ZLAPIDllSubdir;

	FPlatformProcess::PushDllDirectory(*CppAPIDirectory);
	IPCDllHandle = FPlatformProcess::GetDllHandle(*(CppAPIDirectory / TEXT("ZeroLatencyIPC.dll")));
	FPlatformProcess::PopDllDirectory(*CppAPIDirectory);

	if (IPCDllHandle == nullptr)
	{
		CppAPIDirectory = FPaths::EngineDir() / ZLAPIDllSubdir;

		FPlatformProcess::PushDllDirectory(*CppAPIDirectory);
		IPCDllHandle = FPlatformProcess::GetDllHandle(*(CppAPIDirectory / TEXT("ZeroLatencyIPC.dll")));
		FPlatformProcess::PopDllDirectory(*CppAPIDirectory);
	}

	if (IPCDllHandle == nullptr)
	{
		UE_LOG(LogZeroLatencyCore, Warning, TEXT("Could not locate ZeroLatencyAPI.dll!"));
		return;
	}
	else
	{
		UE_LOG(LogZeroLatencyCore, Log, TEXT("Found ZeroLatencyAPI.dll at %s"), *CppAPIDirectory);
	}

	// Use a lambda over instead of a member method here because the signature includes the UWorld::InitializationValues parameter. This would require an Engine/World.h include in our header which would increase compile times.
	OnPostWorldInitHandle = FWorldDelegates::OnPostWorldInitialization.AddLambda([this](UWorld* World, const UWorld::InitializationValues IVS)
	{
		if (!World || !World->IsGameWorld())
		{
			return;
		}

		GameWorld = World;
	});
}

void FZLCoreModule::ShutdownModule()
{
	UE_LOG(LogZeroLatencyCore, Log, TEXT("Shutting down module."));

	CoreModule = nullptr;

	StopZLIPC();

	if (CallbackHandler != nullptr)
	{
		// This object may not be valid during at certain times
		if (CallbackHandler->IsValidLowLevel() && CallbackHandler->IsRooted())
		{
			CallbackHandler->RemoveFromRoot();
		}

		CallbackHandler = nullptr;
	}

	if (OnPostWorldInitHandle.IsValid())
	{
		FWorldDelegates::OnPreWorldInitialization.Remove(OnPostWorldInitHandle);
	}
}

bool FZLCoreModule::IsTickableWhenPaused() const
{
	return true;
}

bool FZLCoreModule::IsTickableInEditor() const
{
	// Ticking in the editor causes the game to connect to the launcher during development.
	return false;
}

void FZLCoreModule::Tick(float DeltaTime)
{
	if (!GameWorld)
	{
		return;
	}

	if (!bRunning)
	{
		auto GI = GameWorld->GetGameInstance();
		if (!GI)
		{
			return;
		}

		auto RefCtr = NewObject<UZLIPCConnectionHandle>();
		RefCtr->OnHandleClosed.AddRaw(this, &FZLCoreModule::StopZLIPC);
		GI->RegisterReferencedObject(RefCtr);

		StartZLIPC();
	}

	zl::Tick((1.0f / DeltaTime)); //TODO: pass in heart beat data here, fps etc
}

TStatId FZLCoreModule::GetStatId() const
{
	return TStatId();
}

UWorld* FZLCoreModule::GetTickableGameObjectWorld() const
{
	return GameWorld;
}

void FZLCoreModule::AssignClientProfile(const FString& clientIp, int newProfileId)
{
	zl::AssignClientProfile(TCHAR_TO_ANSI(*clientIp), newProfileId);
}

void FZLCoreModule::UnassignClientProfile(const FString& clientIp)
{
	zl::UnassignClientProfile(TCHAR_TO_ANSI(*clientIp));
}

void FZLCoreModule::SetGameState(EZLGameState newState)
{
	zl::SetGameState(zl::ToProto(newState));
}

void FZLCoreModule::OnDebugStateDumpCommand()
{
	// Grabs a string of the internal debug state of the API
	char buffer[8192] = { 0 };
	zl::GetDebugStateDumpString(buffer, sizeof(buffer));

	FString fDebugDumpString(buffer);

	// Log to the viewport console (press tilde ~ twice to see)
	APlayerController* PC = (GameWorld ? UGameplayStatics::GetPlayerController(GameWorld, 0) : NULL);
	ULocalPlayer* LocalPlayer = (PC ? Cast<ULocalPlayer>(PC->Player) : NULL);
	if (LocalPlayer && LocalPlayer->ViewportClient && LocalPlayer->ViewportClient->ViewportConsole)
	{
		LocalPlayer->ViewportClient->ViewportConsole->OutputText(fDebugDumpString);
	}

	// Log to standard UE log
	UE_LOG(LogTemp, Log, TEXT("%s"), *fDebugDumpString);
}

void FZLCoreModule::EndGame()
{
	proto::GameResults gameResults;

	zl::EndGame(gameResults);
}

void FZLCoreModule::SetPlayerStats(FZLPlayerStatsMap newStats)
{
	zl::SetPlayerStats(zl::ToProto(newStats));

	// Make a clone and assign it to our local state (because keeping a reference would mean data could change without us calling UpdatePlayerStats)
	*PlayerStatsMap = zl::ToStruct(zl::ToProto(newStats));
}

void FZLCoreModule::SetPlayerScore(FString clientIpAddress, long score)
{
	if (PlayerStatsMap->PlayerStats.Contains(clientIpAddress))
	{
		PlayerStatsMap->PlayerStats[clientIpAddress].Score = score;
	}
	else
	{
		FZLPlayerStats playerStats;
		playerStats.Score = score;
		PlayerStatsMap->PlayerStats.Add(clientIpAddress, playerStats);
	}

	SetPlayerStats(*PlayerStatsMap);
}

void FZLCoreModule::SetPlayerStat(FString clientIpAddress, FString areaId, FString statId, double value)
{
	PlayerStatsMap->SetStat(clientIpAddress, areaId, statId, value);

	SetPlayerStats(*PlayerStatsMap);
}

static int cnt = 0;
void FZLCoreModule::SetPlayerTrackingData(FZLPlayerTrackingData trackingData)
{	
	if (cnt++ % 2 == 0)
	{
		zl::SetPlayerTrackingData(zl::ToProto(trackingData));
	}
}

long FZLCoreModule::GetPlayerScore(FString clientIpAddress)
{
	if (PlayerStatsMap->PlayerStats.Contains(clientIpAddress))
	{
		return PlayerStatsMap->PlayerStats[clientIpAddress].Score;
	}

	return 0;
}

double FZLCoreModule::GetPlayerStat(FString clientIpAddress, FString areaId, FString statId)
{
	if (PlayerStatsMap->PlayerStats.Contains(clientIpAddress))
	{
		auto& playerStats = PlayerStatsMap->PlayerStats[clientIpAddress];
		
		if (playerStats.AreaStats.Contains(areaId))
		{
			auto& areaStats = playerStats.AreaStats[areaId];

			if (areaStats.Stats.Contains(statId))
			{
				return areaStats.Stats[statId];
			}
		}
	}

	return 0.0;
}

void FZLCoreModule::StartZLIPC()
{
	if (!bRunning)
	{
		zl::Start(zl::ELoggingLevel::kLoggingLevelVerbose);

		zl::SetControllerInputChangedCallback(&OnControllerInputChanged);
		zl::SetGameSpaceCalibrationChangedCallback(&OnGameSpaceCalibrationChanged);
		zl::SetGameStateChangedCallback(&OnGameStateChanged);
		zl::SetSessionChangedCallback(&OnSessionChanged);
		zl::SetSiteBoundaryChangedCallback(&OnSiteBoundaryChanged);
		zl::SetGameMasterViewChangedCallback(&OnGameMasterViewChanged);
		zl::SetPlayerProfileMapsChangedCallback(&OnPlayerProfileMapsChanged);

		DebugStateDumpCommand = new FAutoConsoleCommand(
			TEXT("ZLDebugStateDump"),
			TEXT("Prints internal ZLCore state to the screen and output console. Used for development purposes."),
			FConsoleCommandDelegate::CreateRaw(this, &FZLCoreModule::OnDebugStateDumpCommand)
		);

		PlayerStatsMap = new FZLPlayerStatsMap();

		bRunning = true;
	}
}

void FZLCoreModule::StopZLIPC()
{
	if (bRunning)
	{
		zl::Stop();

		zl::SetControllerInputChangedCallback(nullptr);
		zl::SetGameSpaceCalibrationChangedCallback(nullptr);
		zl::SetGameStateChangedCallback(nullptr);
		zl::SetSessionChangedCallback(nullptr);
		zl::SetSiteBoundaryChangedCallback(nullptr);
		zl::SetGameMasterViewChangedCallback(nullptr);
		zl::SetPlayerProfileMapsChangedCallback(nullptr);

		bRunning = false;

		GameWorld = nullptr;
	}
}

FMatrix FZLCoreModule::GetGamespaceCalibrationMatrix()
{
	auto GamespaceCalibration = zl::GetGameSpaceCalibration();

	auto Result = FMatrix::Identity;

	Result.M[0][0] = GamespaceCalibration.m11();
	Result.M[0][1] = GamespaceCalibration.m21();
	Result.M[0][2] = GamespaceCalibration.m31();
	Result.M[1][0] = GamespaceCalibration.m12();
	Result.M[1][1] = GamespaceCalibration.m22();
	Result.M[1][2] = GamespaceCalibration.m31();

	// for the translation components, convert from Unity units (metres) to Unreal units (centimetres).
	Result.M[0][2] *= 100.f;
	Result.M[1][2] *= 100.f;

	if (FMath::IsNearlyZero(Result.GetScaleVector().X) 
		|| FMath::IsNearlyZero(Result.GetScaleVector().Y)
		|| FMath::IsNearlyZero(Result.GetScaleVector().Z))
	{
		Result = FMatrix::Identity;
		Result.M[1][1] = -1.f;
	}

	return Result;
}

EZLGameState FZLCoreModule::GetGameState()
{
	return zl::ToStruct(zl::GetGameState());
}

FZLSession FZLCoreModule::GetSession()
{
	return zl::ToStruct(zl::GetSession());
}

FZLPlayerProfileMaps FZLCoreModule::GetPlayerProfileMaps()
{
	return zl::ToStruct(zl::GetPlayerProfileMaps());
}

FZLGameMasterView FZLCoreModule::GetGameMasterView()
{
	return zl::ToStruct(zl::GetGameMasterView());
}

FZLSiteBoundary FZLCoreModule::GetSiteBoundary()
{
	return zl::ToStruct(zl::GetSiteBoundary());
}

#undef LOCTEXT_NAMESPACE
	
IMPLEMENT_MODULE(FZLCoreModule, ZLCore)
